# ewe_nutrientsupply
### Code for: "Global effect of extreme weather events on nutrient supply" manuscript

This collection of scripts and functions was developed to analyse the effects of extreme weather events (EWEs) on global nutrient supply using Superposed Epoch Analysis (SEA). This notebook provides an example of the calculation based on one nutrient (sodium). 

### Data 

The following datasets are processed:

1) Global Expanded Nutrient model (GENuS)

- URL: https://dataverse.harvard.edu/dataverse/GENuS
- Paper: Smith MR, Micha R, Golden CD, Mozaffarian D, Myers SS. Global Expanded Nutrient Supply (GENuS) Model: A New Method for Estimating the Global Dietary Supply of Nu- trients. PLoS One. 2016; 11(1): e0146976.

2) International Disasters Database (EM-DAT)

- URL: https://www.emdat.be/database
- EM-DAT: The Emergency Events Database - Universit√© catholique de Louvain (UCL) - CRED, D. Guha-Sapir - www.emdat.be, Brussels, Belgium.


### Part 1: Data preparation

#### Step 1: Generating the full EWE dataset

The EWE data from EM-DAT was processed so that one clean dataset with the following information was generated: single-year occurrence, multiyear occurrence, total persons affected, total financial damage, and population/GDP statistics 

```{r}
source("sea_analysis/1.multiyear_events.R")
```

```{r}
# function to find EWEs that occurred in the same country over a consecutive period of years
find_consecutive_years = function(years) {
  groups = split(years, cumsum(c(1, diff(years) != 1)))
  temp = sapply(groups, function(x) {
    if (length(x) == 1) {
      return (data.frame(start_year = x, end_year = x))
    } else {
      return (data.frame(start_year = min(x), end_year = max(x)))
    }
    return(data.frame(t(temp)))
  })
}

# group by country and extract consecutive years for each country
a3_new = ddply(.data = emdat,
               .variables = c("iso", "distype"),
               .fun = function(x) {
                 # print(x$iso)
                 years = x$start_year
                 cons_years = t(find_consecutive_years(years))
                 df = data.frame(cons_years)
                 return(df)
               })
```

#### Step 2: Calculating major EWEs (90th percentiles)

The 90th percentile for total damage, total persons affected, and the proportion of people affected per population or financial damage per GDP was determined.

```{r}
source("sea_analysis/2.thresholds_popdam.R")
```

```{r}
popdam <- filter(combined, 
                     (ppop >= quantile(filta$ppop, 0.9, na.rm=TRUE)) |
                       (pgdp >= quantile(filta$pgdp, 0.9, na.rm=TRUE)) |
                       (sumaff >= quantile(filta$sumaff, 0.9, na.rm=TRUE)) | 
                       (sumdam >= quantile(filta$sumdam, 0.9, na.rm=TRUE))|
                       (totalaff >= quantile(filta$totalaff, 0.9, na.rm=TRUE))|
                       (totaldam >= quantile(filta$totaldam, 0.9, na.rm=TRUE)) )
```


#### Step 3: Generating 5-year windows for sodium

Sodium nutrient supply was downloaded from the GENuS model. After cleaning the data, for each year between 1964-2010, a 5-year window was generated by obtaining the nutrient supply data from two years before and two years after the selected year. 

```{r}
source("sea_analysis/3.5yr_window_nuts.R")
```

```{r}
sod <- cbind(min2 = lag(sodium$start, n=2, default= NA),
              min1 = lag(sodium$start, n=1, default = NA),
              sodium,
              plus1 = lead(sodium$start, n=1, default= NA),
              plus2 = lead(sodium$start, n=2, default=NA))
```

### Part 2: Data analysis

#### Step 4: Combine EWE and nutrient supply data in SEA

Data from the 5-year nutrient supply windows were extracted to match the major EWEs (within the 90th percentile of total persons affected or total financial damage.) 

```{r}
source("sea_analysis/4.5yr_window_EWEs.R")
```
```{r}
for(i in 1:nrow(a2)){
  x = as.data.frame(rbind(c(a2$iso[i], a2$names[i], (a2$start_year[i]:a2$end_year[i]))))
  temp <- rbind.fill(temp,x)
}
temp2 <- melt(temp, id=c("V1", "V2"))
temp2 <- arrange(temp2, V1, V2, value)
temp2$variable <- NULL
colnames(temp2) <- c("iso","names", "start_year")
temp2 <- filter(temp2, !is.na(start_year))
temp2$start_year <- as.numeric(as.character(temp2$start_year))
temp2 <- left_join(temp2, sod, by=c("iso", "start_year"))
```


#### Step 5: Composite 5 year windows globally and by subgroup

The nutrient supply SEA of major EWEs were composited for the global set. ISO country identifiers for EWE occurrence were also matched with low-income subgroups to composite these subgroups individually. 

```{r}
source("sea_analysis/5.5yr_windows_composited.R")
```

```{r}
colnames(res2)<- c("code", "group", "0", "-2", "-1", "+1", "+2")
res2[res2 == "5801"] <- "Least Developed Countries"
res2[res2 == "5802"] <- "Landlocked Developing"
res2[res2 == "5815"] <- "Low Income Food Deficit"
res2[res2 == "5817"] <- "Net Food-Importing Developing"
res2[res2 == "5706"] <- "European Union"
```

#### Step 6: Generate bootstrapped CIs for SEA estimates


```{r}
source("sea_analysis/6.bootstrapped_cis.R")
```

```{r}
meanfun <- function(data, i){
  d <- data[i]
  return(mean(d))
}


myfun <- function(x){
  bo <- boot(x, statistic=meanfun, R=1000)
  merg<- boot.ci(bo, conf=0.95, type="bca")
  #  c(merg$bca[4:5], bo$t0)
  c(merg$bca[4:5], bo$t0)
}

percentage_boot <- sapply(data, myfun)

```


#### Step 7: Determine the distribution Kernel density estimator for comparison groups

To match the yearly distribution of major EWEs, the Kernel density estimator was determined.  

```{r}
source("sea_analysis/7.1000_cntrls_distribution_density.R")
```

```{r}
rdens <- function(n, density=z, data=x, kernel="gaussian") {
  width <- z$bw                              # Kernel width
  rkernel <- function(n) rnorm(n, sd=width)  # Kernel sampler
  sample(x, n, replace=TRUE) + rkernel(n)    # Here's the entire algorithm
}
z <- density(x, kernel="gaussian")
#
# Sample from the KDE.
#

density(y, kernel="gaussian")

hey<- function() {
  y <- rdens(n, z, x)
  y2 <- round(y[y<2008.5 & y>=1963.5])
}

thousand<- as.data.frame(do.call(rbind, replicate(1000, as.matrix(hey()), simplify=FALSE)))
``` 


#### Step 8: Apply kernel density estimator to generate 1000 bootstrapped comparison groups

To create a "business-as-usual" simulation, we generated 1000 bootstrapped false-EWEs. This comparison group had the same yearly distribution as the major EWEs, as confirmed by the Kernel Density estimator above.

```{r}
source("sea_analysis/8.1000_controls_2.R")
```
